{"name":"Hodman","tagline":"Selenium object library ","body":"Hodman\r\n======\r\n\r\nSelenium object library including page-objects.\r\n\r\n[![Build Status](https://secure.travis-ci.org/yahoo/hodman.png)](http://travis-ci.org/yahoo/hodman)\r\n[![npm version](https://badge.fury.io/js/hodman.svg)](http://badge.fury.io/js/hodman)\r\n\r\n[![NPM](https://nodei.co/npm/hodman.png?downloads=true)](https://nodei.co/npm/hodman/)\r\n\r\n\r\n**Table of Contents**\r\n* [Installation](#installation)\r\n* [Getting Started](#getting-started)\r\n* [Usage](#usage)\r\n    * [Page-Objects](#page-objects)\r\n        * [BaseObject](#baseobject)\r\n        * [ViewObject](#viewobject)\r\n        * [PanelObject](#panelobject)\r\n        * [PageObject](#pageobject)\r\n        * [GenericPageObject](#genericpageobject)\r\n    * [Driver-Adapter](#driver-adapter)\r\n    * [Sychronous and asynchronous](#sychronous-and-asynchronous)\r\n* [API-Documentation](#api-documentation)\r\n* [Tests](#tests)\r\n* [Project Naming](#project-naming)\r\n* [Third-party libraries](#third-party-libraries)\r\n* [License](#license)\r\n\r\n\r\n##Installation\r\n\r\nInstall this module with the following command:\r\n```shell\r\nnpm install hodman\r\n```\r\n\r\nAdd the module to your ```package.json``` dependencies:\r\n```shell\r\nnpm install --save hodman\r\n```\r\nAdd the module to your ```package.json``` dev-dependencies:\r\n```shell\r\nnpm install --save-dev hodman\r\n```\r\n\r\nRequire the module in your source-code:\r\n```javascript\r\nvar hodman = require('hodman');\r\n```\r\n\r\n##Getting Started\r\n\r\nThe following example sets-up the page-object system and creates an example page-object for a login page.\r\n\r\n```javascript\r\nvar cabbie = require('cabbie');\r\nvar hodman = require('hodman');\r\n\r\n// Initialize the selenium client. In this case, it is \"cabbie\". \r\nvar driver = cabbie('http://127.0.0.1:4444/wd/hub', \r\n                    { browserName: 'firefox' },  // With firefox\r\n                    { mode: cabbie.MODE_SYNC }); // In sync-mode\r\n\r\n// Create driver-adapter for the page-objects to have a consistent interface \r\n// for all supported selenium clients.\r\nvar driverAdapter = new hodman.driverAdapters.Cabbie(driver);\r\n\r\n// Assign the driver-adapter to the page-object sub-system\r\nhodman.BaseObject.DRIVER_ADAPTER = driverAdapter;\r\n\r\n// Setup path for screenshots\r\nhodman.BaseObject.SCREENSHOT_PATH = __dirname + \"/screens\";\r\n\r\n// Use \"preceptor\" to remove all of the configuration above from your code \r\n// and make this transparent for any testing environment.\r\n\r\n// Create a page-object...\r\n\r\n/**\r\n * @class LoginPage\r\n * @extends PageObject\r\n */\r\nvar LoginPage = hodman.PageObject.extend(\r\n\r\n\t// Constructor (optional)\r\n\tfunction () {\r\n\t\r\n\t\t// ... Some setup\r\n\t\t\r\n\t\t// Overwrite constructor if you need additional parameters.\r\n\t\t// You can use the initialize method for initialization purposes. \r\n\t\t// No need to overwrite the constructor for that.\r\n\r\n\t\t// Call parent constructor after general setup. \r\n\t\t// The initialize method will be called in parent constructor.\r\n\t\tthis.__super(); \r\n\t\t\r\n\t\t// ... Possibly something else\r\n\t},\r\n\t\r\n\t// Prototype\r\n\t{\r\n\t\tinitialize: function () {\r\n\t\t\r\n\t\t\t// Make sure to always call the parent method even if there is non at the time \r\n\t\t\t// of creation. The sub-system will take care of it and create an empty \r\n\t\t\t// function if needed. This will make sure that this page-object will \r\n\t\t\t// pick up any new futures which require initialization.\r\n\t\t\tthis.__super(); \r\n\r\n\t\t\t// Setup selectors (css-selectors) and assign them a name that should be used \r\n\t\t\t// throughout the page-object.\r\n\t\t\t\r\n\t\t\t// Should the selector change in the future, then only this block needs to change.\r\n\t\t\tthis.setSelectors({\r\n\t\t\t\t\"usernameInput\": \".login-username\",\r\n\t\t\t\t\"passwordInput\": \".login-password\",\r\n\t\t\t\t\"rememberMeCheck\": \".remember-me\"\r\n\t\t\t});\r\n\r\n\t\t\t// Any page-object can have load-selectors which are selectors for element that \r\n\t\t\t// are needed for the page to be \"loaded\". Should the Page-object will check \r\n\t\t\t// for these elements to appear on the page before claiming success on\r\n\t\t\tthis.addLoadSelectors([\"usernameInput\"]);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Logs the user in\r\n\t\t *\r\n\t\t * @param {string} username\r\n\t\t * @param {string} password\r\n\t\t * @param {boolean} [rememberMe=false]\r\n\t\t * @return {LoginPage}\r\n\t\t */\r\n\t\tlogin: function (username, password, rememberMe) {\r\n\t\t\t\r\n\t\t\t// Chainable call to set username and password\r\n\t\t\tthis.setUsername(username).setPassword(password);\r\n\t\t\t\r\n\t\t\t// Try to limit the use of control-structures as much as possible since they \r\n\t\t\t// add complexity to the page-objects (and tests). Make it as linear as possible.\r\n\t\t\t// You don't really want to start testing the test system.\r\n\t\t\tif (rememberMe) {\r\n\t\t\t\tthis.checkRememberMe();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Return the page-object itself if the method doesn't return anything \r\n\t\t\t// to make the function chainable\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets a username\r\n\t\t *\r\n\t\t * @param {string} username\r\n\t\t * @return {LoginPage} \r\n\t\t */\r\n\t\tsetUsername: function (username) {\r\n\t\t\r\n\t\t\t// Clear any username already set\r\n\t\t\tthis.clearUsername();\r\n\t\t\t\r\n\t\t\t// Set the value for username\r\n\t\t\tthis.getElement('usernameInput').sendKeys(username);\r\n\t\t\t\r\n\t\t\t// Again, return \"this\"\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Clears any username entered\r\n\t\t *\r\n\t\t * @return {LoginPage}\r\n\t\t */\r\n\t\tclearUsername: function () {\r\n\t\t\tthis.getElement('usernameInput').clear();\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t// ... some other methods\r\n\t},\r\n\t\r\n\t// Static - Copied to the constructor\r\n\t{\r\n\t\t\r\n\t\t// Define static methods here. These methods will be assigned to the constructor and \r\n\t\t// therefore can be called then directly on the constructor itself.\r\n\t\t// \r\n\t\t// For example:\r\n\t\t// LoginPage.navigateTo();\r\n\t\t\r\n\t\t// ...\r\n\t}\r\n```\r\n\r\n##Usage\r\n\r\nHodman currently supplied two types of objects:\r\n* Page-Objects - Objects that abstract the implementation details of websites\r\n* Driver Adapters - Adapters for the page-objects to support multiple Selenium client libraries\r\n\r\nObjects for RESTful API access and storage objects for reusable models is still a WIP.\r\n\r\n###Page-Objects\r\n\r\nSelenium gives low-level access to DOM elements, but that means that with any code-change on the front-end will trigger changes to the tests or the test-code. Already with a couple of tests, this will soon become very work intensive as front-end development in general is moving fast. Maintaining tests this way will get very soon insurmountable.\r\n\r\nPage-objects were defined to get around this problem, and is a design-pattern to abstract the low-level implementation of a website into objects exposing services (not DOM-elements). The tests then will only use these services exposed by the page-object instead of using low-level access to the DOM. Should the DOM structure change, then only the page-object needs to be modified and all the tests should run without a problem thereafter. This is the ideal case, and there are many rules you can abide-to to make this a reality.\r\nThis pattern was introduced by Martin Fowler quite a while ago, and the Selenium project picked it up to be used with Selenium tests. See the following urls for more information on this topic:\r\n\r\n* [Autonomous View / Window Driver - Martin Fowler](http://martinfowler.com/eaaDev/WindowDriver.html)\r\n* [Page-Object Pattern - Martin Fowler](http://martinfowler.com/bliki/PageObject.html)\r\n* [Page-Object Pattern - Selenium Project](https://code.google.com/p/selenium/wiki/PageObjects)\r\n\r\nThe page-object pattern was defined at a time where static websites were standard. Nowadays, websites are much more complex than they used to be, especially with the advent of Single-page applications. In these websites, whole DOM trees are representing one component (i.e. autocomplete) instead of a single element. Also, alerts, prompts, and confirms are not used anymore and might be represented as \"Overlays\" in the DOM of a page, composed of multiple DOM elements. There are many more examples like these, but all of them have one thing in common: they use multiple DOM elements to represent one \"component\" or \"view\".\r\nFor these more modern application, this module implements additional \"page-objects\".\r\n\r\n####Term\r\nThe term page-object does not anymore really mean a whole page but rather the pattern itself. I will refer to ```PageObject``` for a page-object of a whole page.\r\n\r\n####Objects\r\nAll objects use ```preceptor-core```'s ```Base```-object to create inheritance. See the ```preceptor-core``` module page for more information.\r\n\r\n####Context and scope\r\nEvery page-object has its own scope which might be the whole document, or it might be a specific DOM-element with its sub DOM-elements.\r\n\r\nThere are two methods to access the context and scope of a page-object (see API documentation for more information):\r\n* ```getContext``` - Gets the context of the current page-object\r\n* ```getAdapter``` - Gets the driver-adapter for low-level Selenium access\r\n\r\n####BaseObject\r\n\r\nThis page-object is the base-class of all page-objects and should not be used directly. However, this object implements a whole suite of methods for all following page-objects. \r\n\r\nThese methods have the following themes:\r\n* Selector management\r\n* Loaders\r\n* Client accessors\r\n* Screenshot management\r\n* Utility\r\n\r\n#####Selector Management\r\n\r\nThe selector management methods are used to limit the usage of DOM selectors all over the page-object. Should you need to access a DOM element then add it to the selector manager using an identifier. This identifier will then be used in the rest of the page-object to access the DOM-element. Should the selector change, then only this one line in the page-object needs to be changed and none of the other lines of code. Again, this is to reduce maintenance.\r\nThese management methods only support CSS selectors since this is the preferred method of accessing DOM-elements. Front-end engineers are most likely familiar with this type of selector, and they are much more flexible and maintainable since they are generally relative.\r\n\r\nHere is a short list of all selector management methods (see the API documentation for more information):\r\n* ```getSelectors``` - Gets a list of already defined selectors\r\n* ```setSelectors``` - Sets a list of selectors with identifier and selector (key-value pair)\r\n* ```getSelector``` - Determines the selector of a specific identifier\r\n* ```hasSelector``` - Checks if a selector was defined\r\n\r\nYou can set selectors in the ```initialize``` method:\r\n```javascript\r\ninitialize: function () {\r\n\tthis.__super(); // Call parent\r\n\t\t\r\n\tthis.setSelectors({\r\n\t\t\"usernameInput\": \".login-username\", // <key>: <css-selector>\r\n\t\t\"passwordInput\": \".login-password\",\r\n\t\t\"rememberMeCheck\": \".remember-me\"\r\n\t});\r\n}\r\n```\r\n\r\n####Loaders\r\n\r\nLoader methods take a selector identifier, and they make sure that the element exists on the page. For example, when you click on the \"Login\" button of a ```LoginPage```, after a successful login, the browser is redirected to a dashboard-page with the page-object ```DashboardPage```. For this a ```login``` method on the ```LoginPage``` object will fill-in the login information and will click on the submit button, returning the newly created page-object ```LoginPage```. However, the ```LoginPage``` must make sure that it is loaded by checking the loading selectors, possibly timing out with an error when these elements are not found. This will make sure that the test-code is not filled with sleeps, spin-assertions, or even control-structures that would increase the complexity of the tests. Loader methods will add a huge amount of self-testing to the page-objects, simplifying the tests overall.\r\n\r\nHere is a short list of all loader methods (see the API documentation for more information):\r\n* ```verifyIsLoaded``` - Verifies that the page-object is loaded. By default, this will check all load-selectors but it can be overwritten to check even more. This method is called automatically after initialization but can also be called manually afterwards.\r\n* ```addLoadSelector``` - Adds a single load-selector\r\n* ```addLoadSelectors``` - Adds a range of load-selectors\r\n\r\n\r\nYou can add the loading selectors right after declaring the selectors:\r\n```javascript\r\ninitialize: function () {\r\n\tthis.__super(); // Call parent\r\n\t\t\r\n\tthis.setSelectors({\r\n\t\t\"usernameInput\": \".login-username\", // <key>: <css-selector>\r\n\t\t// ...\r\n\t});\r\n\t\r\n\t// Makes sure that \"usernameInput\" is there before completing the initialization process.\r\n\tthis.addLoadSelectors([\"usernameInput\"]);\r\n}\r\n```\r\n\r\n####Client Accessors\r\n\r\nThe client accessors will give access to the DOM elements by providing the selector identifier - you cannot use a css selector directly for these methods.\r\n\r\nHere is a short list of all client-accessor methods (see the API documentation for more information):\r\n* ```getElement``` - Gets the low-level selenium element for a selector identifier\r\n* ```hasElement``` - Checks if the DOM-element for the selector identifier exists\r\n* ```waitForElements``` - Waits for elements to appear in the DOM\r\n\r\n####Screenshot Management\r\n\r\nThe page-objects expose a couple of features to simplify taking screenshots of whole pages or sub-components of a page. This can ideally be used with projects like Kobold to check for visual regressions.\r\n\r\nTo take a screenshot (or parts of the screen) within a page-object, simply call the ```capture``` method. At this point, this is the only method that is inherently asynchronous as it uses some low-level methods that required asynchronicity. To simplify this, the capture method returns a **Promise**.\r\n\r\nIn some cases, you might want to black-out some areas of the screenshot to make sure that the visual regression testing framework doesn't fail on things that are known to change from test to test. For example, creation date labels are areas of the screen that will change from test to test as the time will change; mocking this data might add just too much complexity to the tests. A better way might be just to black-out that area so that it is consistently black for every visual-regression test-run.\r\nThe capture method uses the ```blackOut``` method to determine the coordinates that need to be blacked. One can supply static coordinates or one could supply selector identifiers to determine the coordinates of the DOM-element dynamically.\r\n\r\nHere an example:\r\n```javascript\r\n/**\r\n * @class OrderDetailsPage\r\n * @extends PageObject\r\n */\r\nvar OrderDetailsPage = hodman.PageObject.extend(\r\n\t{\r\n\t\tinitialize: function () {\r\n\t\t\tthis.__super(); // Call parent\r\n\t\t\r\n\t\t\tthis.setSelectors({\r\n\t\t\t\t// ...\r\n\t\t\t\t\"creationDateLabel\": \".order.creation-date\",\r\n\t\t\t\t// ...\r\n\t\t\t});\r\n\t\r\n\t\t\t// ...\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * List of blackout coordinates for the current page-object\r\n\t\t *\r\n\t\t * @return {object[]} With format [{ x:<int>, y:<int>, width:<int>, height:<int> }]\r\n\t\t */\r\n\t\tblackOut: function () {\r\n\t\t\treturn [\r\n\t\t\t\t// Fixed coordinates\r\n\t\t\t\t{ x:10, y:15, width:200, height:100 },\r\n\t\t\t\t\r\n\t\t\t\t// Flexible coordinates of a DOM-element, determined \r\n\t\t\t\t// just before the screenshot is taken\r\n\t\t\t\tthis.getFrame(\"searchField\") \r\n\t\t\t];\r\n\t\t}\r\n\t}\r\n);\r\n```\r\nThen, in the test you can capture the view:\r\n```javascript\r\ntestsuite(\"Order Details\", function () {\r\n\t\r\n\t// ...\r\n\t\r\n\ttest('appearance', function (done) {\r\n\t\r\n\t\t// Take screenshot of order-detail context, black-out areas defined \r\n\t\t// in \"blackOut\", and save the file into the screenshot directory \r\n\t\t// with the name of this test.\r\n\t\tthis.orderPage.capture(this.test.fullTitle()).then(function () {\r\n\t\t\t// Success\r\n\t\t\tdone();\r\n\t\t}, function (err) {\r\n\t\t\t// Failure\r\n\t\t\tdone(err);\r\n\t\t});\r\n\t\t// Unfortunately, this is what needs to be done when tests need to \r\n\t\t// be asynchronous when using asynchronous calls within the test\r\n\t});\r\n\t\r\n\t// ...\r\n});\r\n```\r\n\r\nHere is a short list of all screenshot related methods (see the API documentation for more information):\r\n* ```getFrame``` - Gets the coordinates of a DOM-element by supplying the selector identifier.\r\n* ```blackOut``` - Supplies a list of coordinates that should be blacked-out. ```capture``` calls this method when taking a screenshot.\r\n* ```capture``` - Takes a screenshot of the current context, applying any black-out defined. Should the context be smaller than the whole document, then the screenshot gets clipped to the borders of the context.\r\n\r\n#####Utility\r\nThe page-objects add some utility methods to simplify Selenium testing in general. Here is a short list of all these methods (see the API documentation for more information):\r\n* ```waitUntil``` - This function repeatedly calls the supplied callback-function until it returns true or the timeout is triggered. It uses an additional timeout to reduce the polling, but minimizes with it the wait time. This method can be used instead of static ```sleep```s to check if an element is available or not. It is more flexible and stable as a static ```sleep```. This is also sometimes called a spin-method or combined with assertions as Spin-Assert.\r\n\r\n####ViewObject\r\nCurrently, the ```ViewObject``` inherits directly from the ```BaseObject``` and doesn't add any additional features. This might change in the future, and should therefore be used instead of ```BaseObject```.\r\n\r\n####PanelObject\r\nThe ```PanelObject``` inherits from the ```ViewObject``` and is context aware, meaning that it can determine its own context. For example, a page-object has a table that can be determined by a ```getTableView``` method. This method selects a DOM-element in its own template (for example Handlebars template), an element holding the table DOM-tree in a sub-element with the tag \"table\". However, the page-object doesn't (and shouldn't) have an understanding of the implementation details of the table-view and can therefore not select the root element of the ```TableView```. A ```PanelObject``` can define a ```SELECTOR``` on the constructor to find its own root DOM-element.\r\n\r\nFor example, you have the following handlebars template for an ```OrderPage``` page-object:\r\n```html\r\n...\r\n<div class=\"order-list\">\r\n\t{{view table content=rows}}\r\n</div>\r\n...\r\n```\r\n\r\nThe table object has this view-structure:\r\n```html\r\n...\r\n<table class=\"table-view\">\r\n\t<tr>\r\n\t\t...\r\n\t</tr>\r\n</table>\r\n...\r\n```\r\n\r\nThe ```OrderPage`` page-object exposes the table-view as follows:\r\n```javascript\r\n/**\r\n * @class OrderPage\r\n * @extends PageObject\r\n */\r\nvar OrderPage = hodman.PageObject.extend(\r\n\t{\r\n\t\tinitialize: function () {\r\n\t\t\tthis.__super(); // Call parent\r\n\t\t\r\n\t\t\tthis.setSelectors({\r\n\t\t\t\t// ...\r\n\t\t\t\t// Selects the element in the current view since the \r\n\t\t\t\t// OrderPage should not know anything about how the \r\n\t\t\t\t// table is implemented\r\n\t\t\t\t\"table\": \".order-list\", \r\n\t\t\t\t// ...\r\n\t\t\t});\r\n\t\r\n\t\t\t// ...\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Gets the table-view\r\n\t\t *\r\n\t\t * @return {TableView]\r\n\t\t */\r\n\t\tgetTableView: function () {\r\n\t\t\treturn new TableView(this.getElement('table'));\r\n\t\t}\r\n\t}\r\n);\r\n```\r\n\r\nThe ```TableView``` needs now to make sure that the context is on the correct DOM-element since it should be on the \"table\" tag instead of the parent \"div\":\r\n```javascript\r\n/**\r\n * @class OrderPage\r\n * @extends PanelObject\r\n */\r\nvar OrderPage = hodman.PanelObject.extend(\r\n\r\n\t// On prototype\r\n\t{\r\n\t\tinitialize: function () {\r\n\t\t\tthis.__super(); // Call parent\r\n\t\t\r\n\t\t\tthis.setSelectors({\r\n\t\t\t\t// ...\r\n\t\t\t\t// Selects the element in the current view since the \r\n\t\t\t\t// OrderPage should not know anything about how the \r\n\t\t\t\t// table is implemented\r\n\t\t\t\t\"table\": \".order-list\", \r\n\t\t\t\t// ...\r\n\t\t\t});\r\n\t\r\n\t\t\t// ...\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Gets the table-view\r\n\t\t *\r\n\t\t * @return {TableView]\r\n\t\t */\r\n\t\tgetTableView: function () {\r\n\t\t\t// Getting element with the selector identifier\r\n\t\t\treturn new TableView(this.getElement('table'));\r\n\t\t}\r\n\t},\r\n\t\r\n\t// Defined on the constructor - no need for an instance\r\n\t{\r\n\t\tSELECTOR: \"table.table-view\"\r\n\t}\r\n);\r\n```\r\nWhen the initializer is executed, the ```PanelObject``` will check if there is a SELECTOR defined and uses that selector to select the right DOM-element from the current context, which could be already a sub-section of a page.\r\n\r\n####PageObject\r\n```PageObject```s are specific to whole pages that required urls.\r\nEvery ```PageObject``` can have a couple of properties defined on the constructor to change its behavior:\r\n* ```BASE``` - Base-url of the page. Set this property directly on the ```PageObject``` itself to use it as base-url for all ```PageObject```s.\r\n* ```URL``` - Base-url relative resource locator of the page.\r\n* ```EXPECTED_URL``` - Regex of the expected url. The ```PageObject``` validates that this url is reached when the page-object is created. Should no ```EXPECTED_URL``` be given, then the ```URL``` with ```BASE``` will be used instead. This parameter is a great way to test redirects.\r\n\r\nIt also adds some utility methods to the constructor (see the API documentation for more information):\r\n* ```getBaseUrl``` - Gets the base-url of the ```PageObject```\r\n* ```getUrl``` - Gets the relative path of the url\r\n* ```getNavigationUrl``` - Gets the complete url, combining ```BASE``` and ```URL```\r\n* ```getExpectedUrl``` - Gets the ```EXPECTED_URL``` or ```getNavigationUrl``` if no ```EXPECTED_URL``` is given.\r\n\r\nThe ```PageObject``` inherits from the ```PanelObject``` and therefore also supports a modified context. By default, the whole body is used, but by defining a ```SELECTOR``` one could exclude headers and navigation bars from the ```PageObject``` context since they might implement in their own ```ViewObject``` or ```PanelObject```.\r\n\r\n```javascript\r\n/**\r\n * @class OrderPage\r\n * @extends PageObject\r\n */\r\nvar OrderPage = hodman.PageObject.extend(\r\n\t{\r\n\t\t// ...\r\n\t},\r\n\t\r\n\t{\r\n\t\tURL: \"/orders\"\r\n\t}\r\n);\r\n```\r\n\r\nYou can navigate to this page with:\r\n```javascript\r\nsetup(function () {\r\n\t// Navigate to the page and wait some time if needed \r\n\t// since we know the page is slow\r\n\tthis.ordersPage = OrderPage.navigate(3000);\r\n});\r\n```\r\n\r\n####GenericPageObject\r\nThis object inherits also from ```PanelObject``` and is very similar to the ```PageObject```. However, it was created to be used for ad-hoc page-objects and checking its url. For example, you could use this to test opening external links -  you don't necessarily want to create page-objects but still want to test it. ```navigationUrl``` and ```expectedUrl``` can be directly supplied to the constructor for this object, making sure that you don't have to extend the object. This is currently the only Object that doesn't need to be extended to be used.\r\n\r\n####Sychronous and asynchronous\r\nThis Selenium pattern library currently only supports synchronous Selenium clients. Making these available for asynchronous Selenium clients is a todo item.\r\nHowever, reconsider using synchronous Selenium clients as they simplify your testing-code immensely; the asynchronous behavior of Node can be confusing, having no benefit since the testing script will always have only one user at the same time - it is not a server.\r\nI am in good company with this since Jason Huggins, the creator of Selenium and co-founder of SauceLabs, also advocates for [synchronous node Selenium testing](https://gist.github.com/hugs/9156094).\r\n\r\n###Driver-Adapter\r\n\r\nThe driver-adapter will give the page-objects a consistent way of accessing low-level Selenium elements and functions.\r\n\r\nThe following adapters for Selenium clients are available:\r\n* ```cabbie``` (https://github.com/ForbesLindesay/cabbie)\r\n\r\nHodman exposes all standard driver-adapter with ```hodman.driverAdapters```:\r\n\r\n```javascript\r\nvar cabbie = require('cabbie');\r\nvar hodman = require('hodman');\r\n\r\nvar driver = cabbie('http://127.0.0.1:4444/wd/hub', \r\n                    { browserName: 'firefox' },  // With firefox\r\n                    { mode: cabbie.MODE_SYNC }); // In sync-mode\r\n\r\nvar driverAdapter = new hodman.driverAdapters.Cabbie(driver);\r\n```\r\n\r\nShould your favorite Selenium client not be available, then please request it in the issues tab or implement your own adapter by using the exposed abstract ```DriverAdapter``` object as base-class:\r\n\r\n```javascript\r\nvar hodman = require('hodman');\r\n\r\n// Inherit from DriverAdapter\r\nvar SeleniumClientAdapter = hodman.DriverAdapter.extend(\r\n\r\n    { // Prototype methods\r\n    \r\n       // Implementation\r\n       \r\n    }\r\n);\r\n````\r\nMost of the methods needs to be overwritten as they trigger an error by default to make the developer aware of a missing feature. See the API-documentation for details.\r\n\r\nTo initialize the page-object system, you need to assign the adapter to the BaseObject.DRIVER_ADAPTER property. From that point on, all page-objects will use the supplied driver-adapter to access the browser DOM.\r\n\r\n```javascript\r\nhodman.BaseObject.DRIVER_ADAPTER = driverAdapter;\r\n```\r\n\r\n##API-Documentation\r\n\r\nGenerate the documentation with following command:\r\n```shell\r\nnpm run docs\r\n```\r\nThe documentation will be generated in the ```docs``` folder of the module root.\r\n\r\n##Tests\r\n\r\nRun the tests with the following command:\r\n```shell\r\nnpm run test\r\n```\r\nThe code-coverage will be written to the ```coverage``` folder in the module root.\r\n\r\n##Project Naming\r\nA hodman is mason's laborer who carries bricks, mortar, and cement, helping its master to get the work done. Each part of this project could be considered a brick that is built on top of each other.\r\n\r\n##Third-party libraries\r\n\r\nThe following third-party libraries are used by this module:\r\n\r\n###Dependencies\r\n* pngjs-image: https://github.com/yahoo/pngjs-image\r\n* preceptor-core: https://github.com/yahoo/preceptor-core\r\n* promise: https://github.com/then/promise\r\n* teddybear: https://github.com/AndreasMadsen/teddybear\r\n* underscore: http://underscorejs.org\r\n\r\n###Dev-Dependencies\r\n* chai: http://chaijs.com\r\n* istanbul: https://github.com/gotwarlost/istanbul\r\n* mocha: https://github.com/visionmedia/mocha\r\n* yuidocjs: https://github.com/yui/yuidoc\r\n\r\n##License\r\n\r\nThe MIT License\r\n\r\nCopyright 2014 Yahoo Inc.\r\n","google":"UA-56408730-9","note":"Don't delete this file! It's used internally to help with page regeneration."}